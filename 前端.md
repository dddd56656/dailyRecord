# 1 JS

## 1.1 函数式编程

## 简单来说就是js的函数式编程的简单使用，比如函子，实际上就是装数据的函数且能对里面的数据进行操作。

## 1.2 Promise 

## 同步模式，简单来说就是顺序压入call stack执行。异步模式api，简单来说就是同步会等待，异步会有一个apiWeb，quene去决定异步任务的执行顺序。Promise的使用，简单来说resoleve和rejected就是前端里面的trycatch，但是可以通过then链式调用。然后就是同步任务>微任务>宏任务。每执行完一个宏任务，事件循环会先检查微任务队列，如果有微任务，则优先执行所有微任务，然后再继续处理宏任务。

```text
同步任务（Synchronous Task）：

优先级最高。
这些任务会在主线程上立即执行，不能中断，也不会被放入任务队列。它们是程序执行的基础步骤。
例如：普通的变量赋值、函数调用、console.log() 等。
比喻：同步任务是村庄的基础工作，比如吃饭喝水，村民必须先完成这些任务才能做其他事。

微任务（Microtask）：

优先级次高，仅次于同步任务。
当同步任务完成后，事件循环会立即处理微任务队列中的所有任务，直到微任务队列被清空为止。
微任务包括：
Promise.then()、catch()、finally()。
MutationObserver。
关键点：微任务永远在当前事件循环结束前执行完毕，不会被宏任务打断。
比喻：微任务是村庄的紧急任务，比如修屋顶。同步任务完成后，村民立刻去处理微任务，因为屋顶漏雨影响更大。

宏任务（Macrotask）：

优先级最低。
宏任务会在所有同步任务和微任务完成后，才从宏任务队列中取出一个任务来执行。
宏任务包括：
setTimeout、setInterval。
I/O 操作。
setImmediate（Node.js 环境）。
每执行完一个宏任务，事件循环会先检查微任务队列，如果有微任务，则优先执行所有微任务，然后再继续处理宏任务。
```

## 然后就是使用myPromise复刻Promise源码，实际上就是看源码将相应的方法复刻。  









## 1.3 ECMAScript   自带的各种方法。强类型语言与弱类型语言相比，可以在编译过程中直接发现错误。Flow，插件flow。flow对值，函数，回调函数的类型约束。用flow自定义类型。flow的类型，例如any，自定义类型等。源码中对应的文档。ts,最终编译为js，且类型系统更强大。ts项目初始化流程，修改tsconfig.json，修改编译结果。配置tsc编译的显示结果。js和ts的区别是类型系统，array，tuple。枚举(固定选项的选择)，函数，隐式类型转换成any。export限制作用域，不加则可被全局调用。interface没有意义，主要用来作约束。GC垃圾回收，引用计数，标记清除，标记整理清除。分代回收，年轻代用gc垃圾回收，老年代用增量清除算法。performance监控内存。js的堆栈处理，类似Java，分堆，栈，类区等，在不同的地方开辟不同的空间进行处理。js中对象初始化之后再执行的流程。**堆**存储的是程序员通过**动态分配**请求的内存，通常用于存储对象和需要动态调整大小的数据结构，因此它们是“主动创建”的。栈存储的是局部变量、函数参数等，这些变量的内存由编译器自动管理，因此它们是“被动调用”的。闭包，实际上就是在局部方法中记住本该被销毁的方法。获取document的button来进行onlick的点击监听操作方法和优化方法。jsbench测试js代码运行时间和局部变量运行速度更快，id唯一，class不唯一。防抖和节流操作。通过！减少层级。通过字面量和局部变量会更快。

# 2.前端工程化

## 2.1 前端工程化，实际上就是前端的自动化打包。yeoman,plop生成脚手架的使用，自定义脚手架工具的方法。grunt和gulp的使用。fis的使用。

## 2.2 模块化，**命名导出 (`export {}`)**：可以导出多个值，导入时 `{}` 结构类似对象。**默认导出 (`export default`)**：只能有一个，导入时不需要 `{}`，不会成为 `import * as module` 的一部分。**默认是 `commonjs`，可以用 `require()` 和 `module.exports`**。**`type: "module"` 则强制使用 `import/export` 语法**。**`.cjs` 文件可以绕过 `type: "module"`，仍然使用 CommonJS**。**如果写新项目，推荐用 ESM（即 `type: "module"`）**。**箭头函数 `=>` 的作用。food => food + " + 辣椒"**。`food`：参数（你输入的内容）`=>`：箭头，表示“计算的过程”`food + " + 辣椒"`：箭头右侧是返回值。模块化，就是前端全部打包，webpack的使用。Webpack 本质上是一个**模块打包工具**，它通过解析项目中的 **JavaScript 代码、CSS、图片、字体等资源**，将它们转换为可以在浏览器中高效运行的**打包文件**。rollup的使用。parcel的使用。eslint的使用。tapable的使用。webpack的源码。简单来说，就是利用tapable的特性进行hook编写，通过hook触发写好的方法，底层是ts。webpack本质上是人家用ts写好的可以直接调用里面方法的包。



# 3.vue

## 3.1 主要就是vue的使用方式，本质上来说就是人家写好的可以直接调用里面方法的包。然后就是写好之后，通过nginx部署的方法。之后就是自己重新写一下vue工具包里面的自带的方法。简单来说，就是重新写一些方法，方便对dom进行操作。virtual dom通过snabbdom实现虚拟dom的过程。简单来说就是通过排序，对virtual dom进行更新。

## 3.2 简单来说就是vue的源码，响应式快速排序实现的源码，对virtual dom进行操作的源码，对组件进行操作的源码。vuex的使用和原理，就是一个用来操作内存存储数据的工具类。vue.js的服务端渲染，就是通过nuxt去进行component，数据的组装，生成html返回。nuxt.js的使用，realworld开源项目介绍。ononicons的cdn镜像站。nuxt.js打包和部署。pm2发布部署的使用，github action实现自动化部署(仅支持GitHub，若需要其它，则需要更换其它自动化工具)。用nuxt搭建ssr项目，就是渲染好之后直接展示。gridsome的使用，就是用来快速生成静态页面的一个插件。strapi的使用，就是一个用来快速生成接口的插件。gridsome和strapi，GitHub配合的博客项目。ElementUI的使用，就是用elementUI来制作简陋页面，实际上就是一个组件库依赖包。lerna发布到npm仓库。rollup打包和发布到npm仓库。vue3的使用和原理，就是底层改成了ts，然后有vite配合打包，新增composition api。todolist项目实现。vue3底层的响应式原理重构，简单来说就是把对象里面的信息拦截下来进行再加工。vite的原理，简单来说就是用到哪个就import哪个。    

##  3.3    vue2项目。

##                                                 





































































# 5 node.js

## 5.1 简单来说就是node.js的原理，实际上相当于先接受任务但是不处理。

## 和通过node.js对文件进行读写操作以及对应的原理。 实际是采取批处理的方式对文件进行分割传输。

## 5.2  非关系型数据库，mongoDB,Redis的使用。

## 5.3 

